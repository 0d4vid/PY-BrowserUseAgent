# -*- coding: utf-8 -*-
"""Browser_Use_agent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EEJiw81VKc1RGggI3TQ7XygTJtZEl3UK
"""

!pip install playwright

!playwright install --with-deps chromium

from playwright.async_api import async_playwright

p = await async_playwright().start()
browser = await p.chromium.launch(headless=True)
context = await browser.new_context()
page = await context.new_page()

await page.goto('https://www.pinterest.com')
await page.wait_for_load_state()

from io import BytesIO
from PIL import Image as PILImage
from IPython.display import display

screenshot = await page.screenshot()
img = PILImage.open(BytesIO(screenshot))

width, height = img.size
new_width = int(width * 0.5)
new_height = int(height * 0.5)
img = img.resize((new_width, new_height))


display(img)

from pprint import pprint

clickable_elements = await page.query_selector_all('a, button, [role="button"], [onclick]')
labeled_elements = dict()

for index, element in enumerate (clickable_elements):
  text = await element.inner_text()
  cleanned_text = " ".join(text.split())
  if text:
    labeled_elements[index] = cleanned_text

pprint(labeled_elements)

ffrom openai import OpenAI
from google.colab import userdata

client = OpenAI(
    base_url="https://api.together.xyz/v1",
    api_key=userdata.get("TOGETHER_API_KEY_NEW")
)

tools = [{
    "type": "function",
    "function": {
        "name": "load_page",
        "description": "Go to a webpage.",
        "parameters": {
            "type": "object",
            "properties": {
                "url": {
                    "type": "string"
                }
            },
            "required": [
                "url"
            ],
            "additionalProperties": False
        },
        "strict": True
    }
}, {
    "type": "function",
    "function": {
        "name": "click_element",
        "description": "Click on an element by ID.",
        "parameters": {
            "type": "object",
            "properties": {
                "element_id": {
                    "type": "number"
                }
            },
            "required": [
                "element_id"
            ],
            "additionalProperties": False
        },
        "strict": True
    }
}]

clickable_elements = []

async def get_clickable_elements():
  global clickable_elements

  await page.wait_for_load_state()
  clickable_elements = await page.query_selector_all('a, button, [role="button"], [onclick]')
  labeled_elements = dict()

  for index, element in enumerate(clickable_elements):
    text = await element.inner_text()
    cleaned_text = " ".join(text.split())
    if text and await element.is_visible():
      labeled_elements[index] = cleaned_text

  return "The page has loaded and the following element IDs can be clicked" + json.dumps(labeled_elements)

async def load_page(url):
  await page.goto(url)
  return await get_clickable_elements()

async def click_element(element_id):
  await clickable_elements[element_id].click()
  return await get_clickable_elements()

import json

chat_history = [{"role": "user", "content":
                 "Go to Pinterest and find some interesting images"
                 }]

while True:

  completion = client.chat.completions.create(
      model="meta-llama/Llama-3.3-70B-Instruct-Turbo-Free",
      messages=chat_history,
      tools=tools
  )

  print(completion.choices[0].message.content)
  print(completion.choices[0].message.tool_calls)

  tool_calls = completion.choices[0].message.tool_calls
  if tool_calls:
    chat_history.append(completion.choices[0].message)
    tool_call_name = tool_calls[0].function.name
    if tool_call_name == "load_page":
      url = json.loads(tool_calls[0].function.arguments)["url"]
      result = await load_page(url)
      chat_history.append(
          {"role": "function", "name": tool_call_name, "content": result }
      )
    if tool_call_name == "click_element":
      element_id = json.loads(tool_calls[0].function.arguments)["element_id"]
      result = await click_element(element_id)
      chat_history.append(
          {"role": "function", "name": tool_call_name, "content": result}
      )
  else:
    break

pprint(chat_history)

await clickable_elements[3].click()